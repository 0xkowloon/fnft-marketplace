//INCOMPLETE DRAFT

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

interface IV2Router {
    function addLiquidityETH(
        address _token,
        uint _amountTokenDesired,
        uint _amountTokenMin,
        uint _amountETHMin,
        address _to,
        uint _deadline
    ) external payable returns (uint _amountToken, uint _amountETH, uint _liquidity);

    function removeLiquidityETH(
        address _token,
        uint _liquidity,
        uint _amountTokenMin,
        uint _amountETHMin,
        address _to,
        uint _deadline
    ) external returns (uint _amountToken, uint _amountETH);
}

interface IFNFTStaking {
    function deposit(uint256 _pid, uint256 _amount) external;
    function withdraw(uint256 _pid, uint256 _amount) external;
    function harvest(uint256 _pid) external returns(uint);
}

contract CreatorLiquidity {
    function addLiquidity(        
        address _router,
        uint _amountTokenDesired,
        uint _amountTokenMin,
        uint _amountETHMin,
        uint _deadline
    ) external payable onlyOwner returns(uint _amountToken, uint _amountETH, uint _liquidity) {
        if (!ended) revert SaleActive();
        if (FNFT.balanceOf(address(this)) < _amountTokenDesired) revert OverLimit();
        //TODO: Set LP price protection?

        liquidity += _liquidity;

        (_amountToken, _amountETH, _liquidity) = IV2Router(_router).addLiquidityETH{
            value:msg.value
        }(address(FNFT), _amountTokenDesired, _amountTokenMin, _amountETHMin, address(this), _deadline);

        // refund dust eth, if any
        if (msg.value > _amountETH) _safeTransferETH(msg.sender, msg.value - _amountETH);

        emit LiquidityAdded(_amountToken, _amountETH, _liquidity);
    }

    function removeLiquidity(
        address _router,        
        uint _liquidity,
        uint _amountTokenMin,
        uint _amountETHMin,
        uint _deadline
    ) external onlyOwner  returns (uint _amountToken, uint _amountETH) {
        if (!ended) revert SaleActive();
        if (_liquidity > liquidity) revert OverLimit();
    
        (_amountToken, _amountETH) = IV2Router(_router).removeLiquidityETH(
            address(FNFT), _liquidity, _amountTokenMin, _amountETHMin, address(this), _deadline
        );

        liquidity -= _liquidity;

        _safeTransferETH(msg.sender, _amountETH);

        emit LiquidityRemoved(_amountToken, _amountETH, _liquidity);
    }

    //TODO: Move all these address variables into a controller
    function stakeLiquidity(address _masterchef) external onlyOwner {
        if (!ended) revert SaleActive();
        if (liquidity <= 0) revert NoLiquidityProvided();

        
    }

    function unstakeLiquidity() external onlyOwner {
        if (!ended) revert SaleActive();
        if (liquidity <= 0) revert NoLiquidityProvided();

    }
    
    function harvestLiquidityRewards() external onlyOwner {
        if (!ended) revert SaleActive();
        if (liquidity <= 0) revert NoLiquidityProvided();



        // address(this).balance - totalRaised
    }

    function stakeFNFT(address _staking, uint _pid, uint _amount) external onlyOwner {
        if (!ended) revert SaleActive();
        if (FNFT.balanceOf(address(this)) < _amount) revert OverLimit();

        IFNFTStaking(_staking).deposit(_pid, _amount);
    }

    //TODO: Move all these address variables into a controller
    function unstakeFNFT(address _ART, address _staking, uint _pid, uint _amount) external onlyOwner {
        if (!ended) revert SaleActive();

        IFNFTStaking(_staking).withdraw(_pid, _amount);

        harvestStakeRewards(_ART, _staking, _pid);
    }

    //TODO: Move all these address variables into a controller
    function harvestStakeRewards(address _ART, address _staking, uint _pid) public onlyOwner {
        if (!ended) revert SaleActive();

        IERC20(_ART).safeTransfer(msg.sender, IFNFTStaking(_staking).harvest(_pid));
    }

    //Helper functions

    function _safeTransferETH(address to, uint value) private {
        (bool success,) = to.call{value:value}(new bytes(0));
        if (!success) revert TxFailed();        
    }
}